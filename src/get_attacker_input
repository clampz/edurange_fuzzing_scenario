#!/bin/bash

# if the given arument count isn't equal to two then the script isn't being used correctly
# 		-> print usage and exit
if [ ! $# -eq 2 ]; then

  echo "Usage: get_attacker_input calc lmodtime

calc: path to calculator executable
lmodtime: last time record was modified
"
  exit

fi

cleanup() {

  rm gdb_script_front gdb_script_back run_calc_gdb_script.py.gdb

}

# directory to log the calc outputs and attacker inputs on defending instance
if [ -f "/var/log/fuzz_log" ]; then

  mkdir /var/log/fuzz_log

fi

# files for sandboxing of calculator and input
echo "## run_calc_gdb_script.py.gdb ##

" > gdb_script_front

echo "if myout.count(\"normally\") == 1:
  pass
else:
  wordlist = myout.split(\" \")
  for i, j in enumerate(wordlist):
    if j.find(\"0x\") != -1:
      print(wordlist[i])
end

q
" > gdb_script_back

CALC_EXEC="$1" # calc exec filename
LASTMODIFIED="$2" # last time log was modified
LOGFILE="/tmp/calc_in_out"
DEFENDING_LOG_FILE="/tmp/timestamped_fuzz_log.txt"
SCORING_HOST="10.0.26.128"
ATTACKING_HOST="10.0.26.129"

# while (true):
#  check if /tmp/calc_in_out was modified and went unchecked
#  if true, run the new input in gdb on the calc executable
#  send output, error or some possibly incorrect output to
#  the scorebot to get checked out, and log to attacking and
#  defending machines.
while [ 0 ]; do

  if [ "$(python -c "import os,time; print time.ctime(os.path.getmtime('$LOGFILE'))")" != "$LASTMODIFIED" ]; then

    # check if the script has been signaled to stop
    if [ "$(tail --lines=1 $LOGFILE)" == "stop getting attacker input"  ]; then
  
      cleanup
      echo "game completed" | nc $SCORING_HOST 3456
      exit
  
    fi

    # update current last modified time and grab attacker input
    LASTMODIFIED=$(python -c "import os,time; print time.ctime(os.path.getmtime('$LOGFILE'))")
    INPUT="$(tail --lines=1 $LOGFILE)"
    # create the gdb script and print output to a temporary file
    cp gdb_script_front run_calc_gdb_script.py.gdb
    GDB_SCRIPT_PATH=$(pwd)
    echo "$INPUT" > input_file.txt
    echo "file $CALC_EXEC
python
import string
import gdb
import os
myout = gdb.execute(\"run < input_file.txt 1> $DEFENDING_LOG_FILE 2> $DEFENDING_LOG_FILE\", False, True)
" >> run_calc_gdb_script.py.gdb
    cat gdb_script_back >> run_calc_gdb_script.py.gdb
    TMP_FILE=$(mktemp "./temporary.XXXX")
    gdb -q -x run_calc_gdb_script.py.gdb >> $TMP_FILE

    rm input_file.txt
    # see what the output file contains, i.e. whether calc crashed or not
    # and report accordingly
    if grep -q 'killed' "$TMP_FILE" ; then

      NOW=$(date +%m-%d--%H:%M:%S)
      grep '0x' "./$TMP_FILE" > /var/log/fuzz_log/crash_addr_$NOW.txt
      echo "$($INPUT):1:$(cat /var/log/calc_scenario/crash_addr_$NOW.txt)" | nc $SCORING_HOST 3456 
      echo "$($INPUT):[!!] calculator crashed." | nc $ATTACKING_HOST 2222 
      NOW=""
      rm $TMP_FILE

    else

      NOW=$(date +%m-%d--%H:%M:%S)
      mv $TMP_FILE $NOW.txt
      echo "$INPUT:0:$(echo $INPUT | ./$CALC_EXEC)" | nc $SCORING_HOST 3456 
      echo "$(cat $NOW.txt)" | nc $ATTACKING_HOST 2222
      echo "$NOW: fuzz_data: $INPUT : calc_out: $(cat $NOW.txt)" >> $DEFENDING_LOG_FILE
      rm $NOW.txt
      NOW=""

    fi

    rm run_calc_gdb_script.py.gdb

  fi
  sleep .5

done

